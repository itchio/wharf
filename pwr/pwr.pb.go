// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.1
// source: pwr/pwr.proto

package pwr

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CompressionAlgorithm int32

const (
	CompressionAlgorithm_NONE   CompressionAlgorithm = 0
	CompressionAlgorithm_BROTLI CompressionAlgorithm = 1
	CompressionAlgorithm_GZIP   CompressionAlgorithm = 2
	CompressionAlgorithm_ZSTD   CompressionAlgorithm = 3
)

// Enum value maps for CompressionAlgorithm.
var (
	CompressionAlgorithm_name = map[int32]string{
		0: "NONE",
		1: "BROTLI",
		2: "GZIP",
		3: "ZSTD",
	}
	CompressionAlgorithm_value = map[string]int32{
		"NONE":   0,
		"BROTLI": 1,
		"GZIP":   2,
		"ZSTD":   3,
	}
)

func (x CompressionAlgorithm) Enum() *CompressionAlgorithm {
	p := new(CompressionAlgorithm)
	*p = x
	return p
}

func (x CompressionAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CompressionAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_pwr_pwr_proto_enumTypes[0].Descriptor()
}

func (CompressionAlgorithm) Type() protoreflect.EnumType {
	return &file_pwr_pwr_proto_enumTypes[0]
}

func (x CompressionAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CompressionAlgorithm.Descriptor instead.
func (CompressionAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{0}
}

type HashAlgorithm int32

const (
	HashAlgorithm_SHAKE128_32 HashAlgorithm = 0
	HashAlgorithm_CRC32C      HashAlgorithm = 1
)

// Enum value maps for HashAlgorithm.
var (
	HashAlgorithm_name = map[int32]string{
		0: "SHAKE128_32",
		1: "CRC32C",
	}
	HashAlgorithm_value = map[string]int32{
		"SHAKE128_32": 0,
		"CRC32C":      1,
	}
)

func (x HashAlgorithm) Enum() *HashAlgorithm {
	p := new(HashAlgorithm)
	*p = x
	return p
}

func (x HashAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HashAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_pwr_pwr_proto_enumTypes[1].Descriptor()
}

func (HashAlgorithm) Type() protoreflect.EnumType {
	return &file_pwr_pwr_proto_enumTypes[1]
}

func (x HashAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HashAlgorithm.Descriptor instead.
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{1}
}

type WoundKind int32

const (
	WoundKind_FILE    WoundKind = 0
	WoundKind_SYMLINK WoundKind = 1
	WoundKind_DIR     WoundKind = 2
	// sent when a file portion has been verified as valid
	WoundKind_CLOSED_FILE WoundKind = 3
)

// Enum value maps for WoundKind.
var (
	WoundKind_name = map[int32]string{
		0: "FILE",
		1: "SYMLINK",
		2: "DIR",
		3: "CLOSED_FILE",
	}
	WoundKind_value = map[string]int32{
		"FILE":        0,
		"SYMLINK":     1,
		"DIR":         2,
		"CLOSED_FILE": 3,
	}
)

func (x WoundKind) Enum() *WoundKind {
	p := new(WoundKind)
	*p = x
	return p
}

func (x WoundKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WoundKind) Descriptor() protoreflect.EnumDescriptor {
	return file_pwr_pwr_proto_enumTypes[2].Descriptor()
}

func (WoundKind) Type() protoreflect.EnumType {
	return &file_pwr_pwr_proto_enumTypes[2]
}

func (x WoundKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WoundKind.Descriptor instead.
func (WoundKind) EnumDescriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{2}
}

type SyncHeader_Type int32

const (
	SyncHeader_RSYNC SyncHeader_Type = 0
	// when set, bsdiffTargetIndex must be set
	SyncHeader_BSDIFF SyncHeader_Type = 1
)

// Enum value maps for SyncHeader_Type.
var (
	SyncHeader_Type_name = map[int32]string{
		0: "RSYNC",
		1: "BSDIFF",
	}
	SyncHeader_Type_value = map[string]int32{
		"RSYNC":  0,
		"BSDIFF": 1,
	}
)

func (x SyncHeader_Type) Enum() *SyncHeader_Type {
	p := new(SyncHeader_Type)
	*p = x
	return p
}

func (x SyncHeader_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SyncHeader_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_pwr_pwr_proto_enumTypes[3].Descriptor()
}

func (SyncHeader_Type) Type() protoreflect.EnumType {
	return &file_pwr_pwr_proto_enumTypes[3]
}

func (x SyncHeader_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SyncHeader_Type.Descriptor instead.
func (SyncHeader_Type) EnumDescriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{1, 0}
}

type SyncOp_Type int32

const (
	SyncOp_BLOCK_RANGE    SyncOp_Type = 0
	SyncOp_DATA           SyncOp_Type = 1
	SyncOp_HEY_YOU_DID_IT SyncOp_Type = 2049 // <3 @GranPC & @tomasduda
)

// Enum value maps for SyncOp_Type.
var (
	SyncOp_Type_name = map[int32]string{
		0:    "BLOCK_RANGE",
		1:    "DATA",
		2049: "HEY_YOU_DID_IT",
	}
	SyncOp_Type_value = map[string]int32{
		"BLOCK_RANGE":    0,
		"DATA":           1,
		"HEY_YOU_DID_IT": 2049,
	}
)

func (x SyncOp_Type) Enum() *SyncOp_Type {
	p := new(SyncOp_Type)
	*p = x
	return p
}

func (x SyncOp_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SyncOp_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_pwr_pwr_proto_enumTypes[4].Descriptor()
}

func (SyncOp_Type) Type() protoreflect.EnumType {
	return &file_pwr_pwr_proto_enumTypes[4]
}

func (x SyncOp_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SyncOp_Type.Descriptor instead.
func (SyncOp_Type) EnumDescriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{3, 0}
}

type PatchHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Compression   *CompressionSettings   `protobuf:"bytes,1,opt,name=compression,proto3" json:"compression,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PatchHeader) Reset() {
	*x = PatchHeader{}
	mi := &file_pwr_pwr_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PatchHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PatchHeader) ProtoMessage() {}

func (x *PatchHeader) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PatchHeader.ProtoReflect.Descriptor instead.
func (*PatchHeader) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{0}
}

func (x *PatchHeader) GetCompression() *CompressionSettings {
	if x != nil {
		return x.Compression
	}
	return nil
}

type SyncHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          SyncHeader_Type        `protobuf:"varint,1,opt,name=type,proto3,enum=io.itch.wharf.pwr.SyncHeader_Type" json:"type,omitempty"`
	FileIndex     int64                  `protobuf:"varint,16,opt,name=fileIndex,proto3" json:"fileIndex,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SyncHeader) Reset() {
	*x = SyncHeader{}
	mi := &file_pwr_pwr_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncHeader) ProtoMessage() {}

func (x *SyncHeader) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncHeader.ProtoReflect.Descriptor instead.
func (*SyncHeader) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{1}
}

func (x *SyncHeader) GetType() SyncHeader_Type {
	if x != nil {
		return x.Type
	}
	return SyncHeader_RSYNC
}

func (x *SyncHeader) GetFileIndex() int64 {
	if x != nil {
		return x.FileIndex
	}
	return 0
}

type BsdiffHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TargetIndex   int64                  `protobuf:"varint,1,opt,name=targetIndex,proto3" json:"targetIndex,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BsdiffHeader) Reset() {
	*x = BsdiffHeader{}
	mi := &file_pwr_pwr_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BsdiffHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BsdiffHeader) ProtoMessage() {}

func (x *BsdiffHeader) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BsdiffHeader.ProtoReflect.Descriptor instead.
func (*BsdiffHeader) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{2}
}

func (x *BsdiffHeader) GetTargetIndex() int64 {
	if x != nil {
		return x.TargetIndex
	}
	return 0
}

type SyncOp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          SyncOp_Type            `protobuf:"varint,1,opt,name=type,proto3,enum=io.itch.wharf.pwr.SyncOp_Type" json:"type,omitempty"`
	FileIndex     int64                  `protobuf:"varint,2,opt,name=fileIndex,proto3" json:"fileIndex,omitempty"`
	BlockIndex    int64                  `protobuf:"varint,3,opt,name=blockIndex,proto3" json:"blockIndex,omitempty"`
	BlockSpan     int64                  `protobuf:"varint,4,opt,name=blockSpan,proto3" json:"blockSpan,omitempty"`
	Data          []byte                 `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SyncOp) Reset() {
	*x = SyncOp{}
	mi := &file_pwr_pwr_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncOp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncOp) ProtoMessage() {}

func (x *SyncOp) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncOp.ProtoReflect.Descriptor instead.
func (*SyncOp) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{3}
}

func (x *SyncOp) GetType() SyncOp_Type {
	if x != nil {
		return x.Type
	}
	return SyncOp_BLOCK_RANGE
}

func (x *SyncOp) GetFileIndex() int64 {
	if x != nil {
		return x.FileIndex
	}
	return 0
}

func (x *SyncOp) GetBlockIndex() int64 {
	if x != nil {
		return x.BlockIndex
	}
	return 0
}

func (x *SyncOp) GetBlockSpan() int64 {
	if x != nil {
		return x.BlockSpan
	}
	return 0
}

func (x *SyncOp) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type SignatureHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Compression   *CompressionSettings   `protobuf:"bytes,1,opt,name=compression,proto3" json:"compression,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignatureHeader) Reset() {
	*x = SignatureHeader{}
	mi := &file_pwr_pwr_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignatureHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignatureHeader) ProtoMessage() {}

func (x *SignatureHeader) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignatureHeader.ProtoReflect.Descriptor instead.
func (*SignatureHeader) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{4}
}

func (x *SignatureHeader) GetCompression() *CompressionSettings {
	if x != nil {
		return x.Compression
	}
	return nil
}

type BlockHash struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	WeakHash      uint32                 `protobuf:"varint,1,opt,name=weakHash,proto3" json:"weakHash,omitempty"`
	StrongHash    []byte                 `protobuf:"bytes,2,opt,name=strongHash,proto3" json:"strongHash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlockHash) Reset() {
	*x = BlockHash{}
	mi := &file_pwr_pwr_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockHash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockHash) ProtoMessage() {}

func (x *BlockHash) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockHash.ProtoReflect.Descriptor instead.
func (*BlockHash) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{5}
}

func (x *BlockHash) GetWeakHash() uint32 {
	if x != nil {
		return x.WeakHash
	}
	return 0
}

func (x *BlockHash) GetStrongHash() []byte {
	if x != nil {
		return x.StrongHash
	}
	return nil
}

type CompressionSettings struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Algorithm     CompressionAlgorithm   `protobuf:"varint,1,opt,name=algorithm,proto3,enum=io.itch.wharf.pwr.CompressionAlgorithm" json:"algorithm,omitempty"`
	Quality       int32                  `protobuf:"varint,2,opt,name=quality,proto3" json:"quality,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompressionSettings) Reset() {
	*x = CompressionSettings{}
	mi := &file_pwr_pwr_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompressionSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressionSettings) ProtoMessage() {}

func (x *CompressionSettings) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompressionSettings.ProtoReflect.Descriptor instead.
func (*CompressionSettings) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{6}
}

func (x *CompressionSettings) GetAlgorithm() CompressionAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return CompressionAlgorithm_NONE
}

func (x *CompressionSettings) GetQuality() int32 {
	if x != nil {
		return x.Quality
	}
	return 0
}

type ManifestHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Compression   *CompressionSettings   `protobuf:"bytes,1,opt,name=compression,proto3" json:"compression,omitempty"`
	Algorithm     HashAlgorithm          `protobuf:"varint,2,opt,name=algorithm,proto3,enum=io.itch.wharf.pwr.HashAlgorithm" json:"algorithm,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ManifestHeader) Reset() {
	*x = ManifestHeader{}
	mi := &file_pwr_pwr_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ManifestHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManifestHeader) ProtoMessage() {}

func (x *ManifestHeader) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ManifestHeader.ProtoReflect.Descriptor instead.
func (*ManifestHeader) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{7}
}

func (x *ManifestHeader) GetCompression() *CompressionSettings {
	if x != nil {
		return x.Compression
	}
	return nil
}

func (x *ManifestHeader) GetAlgorithm() HashAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return HashAlgorithm_SHAKE128_32
}

type ManifestBlockHash struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Hash          []byte                 `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ManifestBlockHash) Reset() {
	*x = ManifestBlockHash{}
	mi := &file_pwr_pwr_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ManifestBlockHash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManifestBlockHash) ProtoMessage() {}

func (x *ManifestBlockHash) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ManifestBlockHash.ProtoReflect.Descriptor instead.
func (*ManifestBlockHash) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{8}
}

func (x *ManifestBlockHash) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

// Wounds files format: header, container, then any
// number of Wounds
type WoundsHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WoundsHeader) Reset() {
	*x = WoundsHeader{}
	mi := &file_pwr_pwr_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WoundsHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WoundsHeader) ProtoMessage() {}

func (x *WoundsHeader) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WoundsHeader.ProtoReflect.Descriptor instead.
func (*WoundsHeader) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{9}
}

// Describe a corrupted portion of a file, in [start,end)
type Wound struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Index         int64                  `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Start         int64                  `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End           int64                  `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	Kind          WoundKind              `protobuf:"varint,4,opt,name=kind,proto3,enum=io.itch.wharf.pwr.WoundKind" json:"kind,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Wound) Reset() {
	*x = Wound{}
	mi := &file_pwr_pwr_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Wound) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Wound) ProtoMessage() {}

func (x *Wound) ProtoReflect() protoreflect.Message {
	mi := &file_pwr_pwr_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Wound.ProtoReflect.Descriptor instead.
func (*Wound) Descriptor() ([]byte, []int) {
	return file_pwr_pwr_proto_rawDescGZIP(), []int{10}
}

func (x *Wound) GetIndex() int64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *Wound) GetStart() int64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *Wound) GetEnd() int64 {
	if x != nil {
		return x.End
	}
	return 0
}

func (x *Wound) GetKind() WoundKind {
	if x != nil {
		return x.Kind
	}
	return WoundKind_FILE
}

var File_pwr_pwr_proto protoreflect.FileDescriptor

const file_pwr_pwr_proto_rawDesc = "" +
	"\n" +
	"\rpwr/pwr.proto\x12\x11io.itch.wharf.pwr\"W\n" +
	"\vPatchHeader\x12H\n" +
	"\vcompression\x18\x01 \x01(\v2&.io.itch.wharf.pwr.CompressionSettingsR\vcompression\"\x81\x01\n" +
	"\n" +
	"SyncHeader\x126\n" +
	"\x04type\x18\x01 \x01(\x0e2\".io.itch.wharf.pwr.SyncHeader.TypeR\x04type\x12\x1c\n" +
	"\tfileIndex\x18\x10 \x01(\x03R\tfileIndex\"\x1d\n" +
	"\x04Type\x12\t\n" +
	"\x05RSYNC\x10\x00\x12\n" +
	"\n" +
	"\x06BSDIFF\x10\x01\"0\n" +
	"\fBsdiffHeader\x12 \n" +
	"\vtargetIndex\x18\x01 \x01(\x03R\vtargetIndex\"\xe4\x01\n" +
	"\x06SyncOp\x122\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1e.io.itch.wharf.pwr.SyncOp.TypeR\x04type\x12\x1c\n" +
	"\tfileIndex\x18\x02 \x01(\x03R\tfileIndex\x12\x1e\n" +
	"\n" +
	"blockIndex\x18\x03 \x01(\x03R\n" +
	"blockIndex\x12\x1c\n" +
	"\tblockSpan\x18\x04 \x01(\x03R\tblockSpan\x12\x12\n" +
	"\x04data\x18\x05 \x01(\fR\x04data\"6\n" +
	"\x04Type\x12\x0f\n" +
	"\vBLOCK_RANGE\x10\x00\x12\b\n" +
	"\x04DATA\x10\x01\x12\x13\n" +
	"\x0eHEY_YOU_DID_IT\x10\x81\x10\"[\n" +
	"\x0fSignatureHeader\x12H\n" +
	"\vcompression\x18\x01 \x01(\v2&.io.itch.wharf.pwr.CompressionSettingsR\vcompression\"G\n" +
	"\tBlockHash\x12\x1a\n" +
	"\bweakHash\x18\x01 \x01(\rR\bweakHash\x12\x1e\n" +
	"\n" +
	"strongHash\x18\x02 \x01(\fR\n" +
	"strongHash\"v\n" +
	"\x13CompressionSettings\x12E\n" +
	"\talgorithm\x18\x01 \x01(\x0e2'.io.itch.wharf.pwr.CompressionAlgorithmR\talgorithm\x12\x18\n" +
	"\aquality\x18\x02 \x01(\x05R\aquality\"\x9a\x01\n" +
	"\x0eManifestHeader\x12H\n" +
	"\vcompression\x18\x01 \x01(\v2&.io.itch.wharf.pwr.CompressionSettingsR\vcompression\x12>\n" +
	"\talgorithm\x18\x02 \x01(\x0e2 .io.itch.wharf.pwr.HashAlgorithmR\talgorithm\"'\n" +
	"\x11ManifestBlockHash\x12\x12\n" +
	"\x04hash\x18\x01 \x01(\fR\x04hash\"\x0e\n" +
	"\fWoundsHeader\"w\n" +
	"\x05Wound\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x03R\x05index\x12\x14\n" +
	"\x05start\x18\x02 \x01(\x03R\x05start\x12\x10\n" +
	"\x03end\x18\x03 \x01(\x03R\x03end\x120\n" +
	"\x04kind\x18\x04 \x01(\x0e2\x1c.io.itch.wharf.pwr.WoundKindR\x04kind*@\n" +
	"\x14CompressionAlgorithm\x12\b\n" +
	"\x04NONE\x10\x00\x12\n" +
	"\n" +
	"\x06BROTLI\x10\x01\x12\b\n" +
	"\x04GZIP\x10\x02\x12\b\n" +
	"\x04ZSTD\x10\x03*,\n" +
	"\rHashAlgorithm\x12\x0f\n" +
	"\vSHAKE128_32\x10\x00\x12\n" +
	"\n" +
	"\x06CRC32C\x10\x01*<\n" +
	"\tWoundKind\x12\b\n" +
	"\x04FILE\x10\x00\x12\v\n" +
	"\aSYMLINK\x10\x01\x12\a\n" +
	"\x03DIR\x10\x02\x12\x0f\n" +
	"\vCLOSED_FILE\x10\x03B\x1dZ\x1bgithub.com/itchio/wharf/pwrb\x06proto3"

var (
	file_pwr_pwr_proto_rawDescOnce sync.Once
	file_pwr_pwr_proto_rawDescData []byte
)

func file_pwr_pwr_proto_rawDescGZIP() []byte {
	file_pwr_pwr_proto_rawDescOnce.Do(func() {
		file_pwr_pwr_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pwr_pwr_proto_rawDesc), len(file_pwr_pwr_proto_rawDesc)))
	})
	return file_pwr_pwr_proto_rawDescData
}

var file_pwr_pwr_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_pwr_pwr_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_pwr_pwr_proto_goTypes = []any{
	(CompressionAlgorithm)(0),   // 0: io.itch.wharf.pwr.CompressionAlgorithm
	(HashAlgorithm)(0),          // 1: io.itch.wharf.pwr.HashAlgorithm
	(WoundKind)(0),              // 2: io.itch.wharf.pwr.WoundKind
	(SyncHeader_Type)(0),        // 3: io.itch.wharf.pwr.SyncHeader.Type
	(SyncOp_Type)(0),            // 4: io.itch.wharf.pwr.SyncOp.Type
	(*PatchHeader)(nil),         // 5: io.itch.wharf.pwr.PatchHeader
	(*SyncHeader)(nil),          // 6: io.itch.wharf.pwr.SyncHeader
	(*BsdiffHeader)(nil),        // 7: io.itch.wharf.pwr.BsdiffHeader
	(*SyncOp)(nil),              // 8: io.itch.wharf.pwr.SyncOp
	(*SignatureHeader)(nil),     // 9: io.itch.wharf.pwr.SignatureHeader
	(*BlockHash)(nil),           // 10: io.itch.wharf.pwr.BlockHash
	(*CompressionSettings)(nil), // 11: io.itch.wharf.pwr.CompressionSettings
	(*ManifestHeader)(nil),      // 12: io.itch.wharf.pwr.ManifestHeader
	(*ManifestBlockHash)(nil),   // 13: io.itch.wharf.pwr.ManifestBlockHash
	(*WoundsHeader)(nil),        // 14: io.itch.wharf.pwr.WoundsHeader
	(*Wound)(nil),               // 15: io.itch.wharf.pwr.Wound
}
var file_pwr_pwr_proto_depIdxs = []int32{
	11, // 0: io.itch.wharf.pwr.PatchHeader.compression:type_name -> io.itch.wharf.pwr.CompressionSettings
	3,  // 1: io.itch.wharf.pwr.SyncHeader.type:type_name -> io.itch.wharf.pwr.SyncHeader.Type
	4,  // 2: io.itch.wharf.pwr.SyncOp.type:type_name -> io.itch.wharf.pwr.SyncOp.Type
	11, // 3: io.itch.wharf.pwr.SignatureHeader.compression:type_name -> io.itch.wharf.pwr.CompressionSettings
	0,  // 4: io.itch.wharf.pwr.CompressionSettings.algorithm:type_name -> io.itch.wharf.pwr.CompressionAlgorithm
	11, // 5: io.itch.wharf.pwr.ManifestHeader.compression:type_name -> io.itch.wharf.pwr.CompressionSettings
	1,  // 6: io.itch.wharf.pwr.ManifestHeader.algorithm:type_name -> io.itch.wharf.pwr.HashAlgorithm
	2,  // 7: io.itch.wharf.pwr.Wound.kind:type_name -> io.itch.wharf.pwr.WoundKind
	8,  // [8:8] is the sub-list for method output_type
	8,  // [8:8] is the sub-list for method input_type
	8,  // [8:8] is the sub-list for extension type_name
	8,  // [8:8] is the sub-list for extension extendee
	0,  // [0:8] is the sub-list for field type_name
}

func init() { file_pwr_pwr_proto_init() }
func file_pwr_pwr_proto_init() {
	if File_pwr_pwr_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pwr_pwr_proto_rawDesc), len(file_pwr_pwr_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_pwr_pwr_proto_goTypes,
		DependencyIndexes: file_pwr_pwr_proto_depIdxs,
		EnumInfos:         file_pwr_pwr_proto_enumTypes,
		MessageInfos:      file_pwr_pwr_proto_msgTypes,
	}.Build()
	File_pwr_pwr_proto = out.File
	file_pwr_pwr_proto_goTypes = nil
	file_pwr_pwr_proto_depIdxs = nil
}
